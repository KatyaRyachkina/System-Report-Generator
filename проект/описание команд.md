__init__(self, fmt: str = "text")
Команды и вызовы:

python
datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")  # Текущее время в формате ГГГГ-ММ-ДД ЧЧ:ММ:СС
Что происходит:

Создается экземпляр класса с указанием формата вывода

Инициализируется словарь self.info для хранения всех данных

Фиксируется время создания отчета для дальнейшего использования во всех разделах

collect(self) -> Dict[str, Any]
Команды и последовательность:

python
self.info = {
    "time": self._get_current_time(),
    "platform": self._call_platform_info(),
    "cpu": self._execute_cpu_collection(),
    "memory": self._run_memory_check(),
    "disks": self._scan_disk_partitions(),
    "network": self._gather_network_stats(),
    "processes": self._list_running_processes(),
    "users": self._get_active_sessions(),
    "boot": self._query_boot_time(),
    "sensors": self._read_sensor_data()
}
Подробный процесс:

Запуск сбора данных по всем подсистемам

Последовательный вызов 10 специализированных методов

Структурирование данных в единый словарь

Возврат полного набора системной информации

_platform(self) -> Dict[str, str]
Системные команды:

python
platform.system()      # Возвращает: 'Windows', 'Linux', 'Darwin' (macOS)
platform.release()     # Версия релиза ОС: '10', '11', '5.15.0-91-generic'
platform.version()     # Детальная версия сборки
socket.gethostname()   # Имя компьютера в сети
socket.gethostbyname() # Основной IP-адрес
Собираемые данные:

Идентификация ОС: тип, версия, сборка

Сетевые параметры: hostname и первичный IP

Архитектура: информация о разрядности системы

_cpu(self) -> Dict[str, Any]
Команды мониторинга CPU:

python
psutil.cpu_count(logical=False)    # Физические ядра
psutil.cpu_count(logical=True)     # Логические ядра (с Hyper-Threading)
psutil.cpu_freq()                  # Частота: current, min, max
psutil.cpu_percent(interval=0.5)   # Загрузка за 500 мс
psutil.cpu_percent(percpu=True)    # Загрузка по каждому ядру отдельно
Метрики процессора:

Топология: число физических/логических процессоров

Частотные характеристики: текущая, минимальная, максимальная частота

Утилизация: общая и поядерная загрузка в процентах

Статистика: агрегированные данные за период измерения

_memory(self) -> Dict[str, Any]
Команды работы с памятью:

python
psutil.virtual_memory()  # RAM: total, available, percent, used, free
psutil.swap_memory()     # SWAP: total, used, free, percent, sin, sout
Вычисляемые показатели:

Оперативная память:

total: общий объем установленной RAM

used: используемая память приложениями

available: реально доступная память (включая кэш)

percent: процент использования

Файл подкачки:

Размер swap-раздела

Активность обмена с диском (swap in/out)

_disks(self) -> List[Dict[str, Any]]
Дисковые операции:

python
psutil.disk_partitions()          # Список всех разделов
psutil.disk_usage(mountpoint)     # Использование пространства
psutil.disk_io_counters(perdisk=True)  # I/O статистика по устройствам
Алгоритм сбора:

Перечисление разделов: все смонтированные файловые системы

Анализ использования: расчет свободного/занятого пространства

Сбор статистики IO:

read_bytes: прочитано с момента загрузки

write_bytes: записано с момента загрузки

read_count: количество операций чтения

write_count: количество операций записи

Обработка исключений: пропуск системных/защищенных разделов

_network(self) -> Dict[str, Any]
Сетевые команды:

python
psutil.net_io_counters()          # Общая сетевая статистика
psutil.net_if_addrs()             # Адреса интерфейсов (IP, MAC)
psutil.net_if_stats()             # Статус интерфейсов (up/down, speed, mtu)
socket.AF_INET                    # Константа для IPv4
socket.AF_INET6                   # Константа для IPv6
psutil.AF_LINK                    # Константа для MAC-адресов
Собираемая сетевая информация:

1. Общая статистика:

bytes_sent: всего отправлено байт

bytes_recv: всего получено байт

packets_sent: количество отправленных пакетов

packets_recv: количество полученных пакетов

2. По каждому интерфейсу:

IP-адреса: IPv4 с маской, IPv6

MAC-адрес: физический адрес сетевой карты

Статус: включен/выключен

Скорость: в Mbps (мегабит в секунду)

MTU: Maximum Transmission Unit

_processes(self) -> List[Dict[str, Any]]
Команды работы с процессами:

python
psutil.process_iter(['pid', 'name', ...])  # Итератор по процессам
p.info                                      # Словарь с информацией о процессе
psutil.Process(pid).memory_info().rss       # Resident Set Size (фактическая RAM)
Алгоритм работы:

Итерация по процессам: получение всех запущенных процессов

Сбор метрик:

pid: идентификатор процесса

name: имя исполняемого файла

cpu_percent: загрузка CPU процессом

memory_percent: использование RAM в процентах

memory_mb: использование RAM в мегабайтах

Сортировка и фильтрация:

Сортировка по убыванию использования памяти

Выбор топ-8 самых "прожорливых" процессов

Обработка исключений для системных процессов

_users(self) -> List[Dict[str, Any]]
Команды работы с пользователями:

python
psutil.users()                     # Активные пользовательские сессии
datetime.datetime.fromtimestamp()  # Конвертация UNIX времени
Информация о сессиях:

Имя пользователя: логин в системе

Хост: откуда подключен (localhost или удаленный адрес)

Время начала: когда началась сессия

Терминал: tty или pts (для Linux/Unix)

_boot(self) -> str
Команда получения времени загрузки:

python
psutil.boot_time()  # UNIX timestamp времени последней загрузки
Преобразование:

Получение timestamp (секунды с 1 января 1970)

Конвертация в объект datetime

Форматирование в человеко-читаемый вид

_sensors(self) -> Dict[str, Any]
Команды работы с датчиками:

python
psutil.sensors_temperatures()  # Температурные датчики
psutil.sensors_fans()          # Датчики вентиляторов (не используется)
psutil.sensors_battery()       # Информация о батарее (не используется)
Доступные датчики:

Температура: CPU, GPU, материнской платы, дисков

Значения: current (текущая), high (максимальная), critical (критическая)

Платформенные особенности: реализовано не на всех системах

text_report(self) -> str
Форматирующие операции:

python
"СИСТЕМНЫЙ ОТЧЕТ - {self.time}".center(60)  # Центрирование заголовка
f"{mem['used_ram']} / {mem['total_ram']}"   # Форматирование значений
", ".join([f'{p}%' for p in cpu['per_cpu']]) # Объединение списка
f"{proc['name'][:20]:20}"                    # Обрезка и выравнивание
Структура отчета:

text
1. ШАПКА ОТЧЕТА
   ============================================
   СИСТЕМНЫЙ ОТЧЕТ - 2024-01-15 14:30:00
   ============================================

2. РАЗДЕЛ ПЛАТФОРМЫ
   --------------------------------------------
   Система: Windows 10
   Версия: 10.0.19045
   Хост: DESKTOP-ABC123
   IP-адрес: 192.168.1.100

3. РАЗДЕЛ ПРОЦЕССОРА
   --------------------------------------------
   Ядра: 4 физических, 8 логических
   Частота: 3600 MHz
   Загрузка: 24.5%
   По ядрам: 15%, 30%, 10%, 45%, ...

... и так далее по всем разделам
json_report(self) -> str
Команды сериализации:

python
json.dumps(
    self.info,           # Данные для сериализации
    indent=2,            # Отступы для читаемости
    default=str,         # Обработка несериализуемых типов
    ensure_ascii=False   # Поддержка Unicode
)
Особенности формата:

Структурированные данные: полное дерево информации

Машиночитаемый формат: для автоматической обработки

Поддержка сложных типов: datetime, объекты psutil

save(self, fname: str = None) -> str
Файловые операции:

python
# Генерация имени файла
f"system_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

# Определение расширения
".json" if self.fmt == "json" else ".txt"

# Запись файла
with open(fname, 'w', encoding='utf-8') as f:
    f.write(content)  # content: json_report() или text_report()
Логика именования:

Автоматическое: system_report_20240115_143000.json

Ручное: my_report.txt (если указан параметр fname)

Сохранение в текущей директории

main() - аргументы командной строки
Поддерживаемые флаги:

bash
# Базовый вызов
python system_report.py

# Создание JSON отчета
python system_report.py --format json

# Сохранение в конкретный файл
python system_report.py -o my_system_info.txt

# Вывод в консоль и сохранение
python system_report.py --print --format json -o report.json

# Все опции вместе
python system_report.py --format text --output full_report --print
Обрабатываемые аргументы:

--format: выбор между человеко-читаемым (text) и машино-читаемым (json)

--output / -o: указание имени файла (без расширения)

--print / -p: дублирование вывода в консоль
